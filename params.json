{
  "name": "Tutoriel-fullstack-js-4-riot",
  "tagline": "Tutoriel Fullstack JavaScript - Chapitre 4 - Riot",
  "body": "# Riot\r\n\r\n## Qu'est-ce qu'un composant?\r\n\r\nLe dévéloppement par composants a été popularisé par la librairie [ReactJS](https://facebook.github.io/react/) de Facebook. Un composant est un élément HTML contenant la vue ainsi que les controleurs qui y sont associés. Dans notre application nous avons deux parties: \r\n\r\n* la liste ```<div id=\"liste\">```\r\n* le formulaire pour ajouter quelque chose à faire ou supprimer ce qui a été fait, ```<div id=\"formulaire\">```. \r\n\r\nUne fois transformés en composants, le corps du document HTML ressemblera à ça:\r\n\r\n```\r\n<div id=\"contenu\">\r\n <a-faire-liste></a-faire-liste>\r\n <a-faire-formulaire></a-faire-formulaire>\r\n</div>\r\n``` \r\n\r\n## Pourquoi Riot?\r\n\r\nJ'ai choisi d'utiliser Riot plutôt que React. D'une part parce que Riot est une librairie beaucoup plus légère. Et d'autre part parce que contrairement à React, qui une syntaxe bien à elle, Riot n'utilise que du javascript tout à fait classique.\r\n\r\n### Mise en place\r\n\r\nCréez un dossier ```4.riot``` et initialisez NPM.\r\n\r\n```\r\n$ npm init\r\n```\r\n\r\nTéléchargez les librairies ```riot``` et ```riotify```. ```riotify``` comme ```browserify-handlebars``` dans le [chapitre précédant](link_to_do) sert à convertir les fichiers ```.tag``` de riot en javascript lors de la construction du scripte final avec ```browserify```.\r\n\r\n```\r\n$ npm install riot riotify --save\r\n```\r\n\r\nCréez un fichier ```main.js``` et un dossier ```public``` à la racine du projet et ajoutez un scripte ```build``` à ```package.json```. Nous y ajoutons également un scripte ```watch``` qui met à jour ```public/script.js``` automatiquement pendant que nous nous travaillons dessus.\r\n\r\n```\r\n{\r\n  \"name\": \"4.riot\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"main.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\r\n    \"build\": \"browserify main.js -o public/script.js -t riotify | minify public/script.js -o public/script.js\",\r\n    \"watch\": \"watchify main.js -o public/script.js -t riotify\"\r\n  },\r\n  \"author\": \"idris-maps.com\",\r\n  \"license\": \"GPL-2.0\",\r\n  \"dependencies\": {\r\n    \"riot\": \"^2.3.18\",\r\n    \"riotify\": \"^1.0.0\"\r\n  }\r\n}\r\n```\r\n\r\nDans ```public```, ajoutez ```style.css``` du [chapitre \"Mise en page\"](link_to_do) et créez un fichier ```index.html``` comme suit.\r\n\r\n```\r\n<!doctype html>\r\n<html>\r\n <head>\r\n  <meta charset=\"utf-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>\r\n  <title>Riot</title>\r\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\" integrity=\"sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7\" crossorigin=\"anonymous\">\r\n<!-- notre feuille de style -->\r\n  <link rel=\"stylesheet\" href=\"style.css\">\r\n </head>\r\n <body>\r\n  <div id=\"contenu\">\r\n   <h1>À faire</h1>\r\n   <a-faire-liste></a-faire-liste>\r\n   <a-faire-formulaire></a-faire-formulaire>\r\n  </div>\r\n  <script src=\"script.js\"></script>\r\n </body>\r\n</html>\r\n```\r\n\r\nCréez un dossier ```lib``` et copiez y ```Modele-a-faire.js``` du [chapitre 2](link_to_do) et créez un dossier ```composants```.\r\n\r\nNotre dossier ```4.riot``` ressemble à ça:\r\n\r\n```\r\n4.riot\r\n  -lib\r\n    -composants\r\n    Modele-a-faire.js\r\n  -node_modules\r\n    ...\r\n  -public\r\n    index.html\r\n    style.css\r\n  main.js\r\n  package.json\r\n```\r\n\r\n### Le composant ```<a-faire-liste>```\r\n\r\nDans ```lib/composants```, créez un fichier ```a-faire-liste.tag```\r\n\r\n```\r\n<div class=\"liste-element a-faire\">\r\n\r\n <div class=\"liste-element-info\">\r\n  <div class=\"liste-element-texte\">\r\n   <p>En cours de modification</p>\r\n  </div>\r\n  <div class=\"liste-element-modif\">\r\n   <span class=\"glyphicon glyphicon-pencil\"></span>\r\n  </div>\r\n  <div class=\"liste-element-statut\">\r\n   <span class=\"glyphicon glyphicon-ok\"></span>\r\n  </div>\r\n </div>\r\n\r\n <div class=\"liste-element-maj\">\r\n  <div class=\"liste-element-maj-input\">\r\n   <input class=\"form-control\" id=\"liste-element-maj-input\" type=\"text\">\r\n  </div>\r\n  <div class=\"liste-element-maj-bouton\">\r\n   <button class=\"btn btn-primary\" id=\"liste-element-maj-bouton\">OK</button>\r\n  </div>\r\n </div>\r\n\r\n</div> \r\n```\r\n\r\nJ'ai pris le HTML d'un des éléments de liste de ```index.html``` du [chapitre 1](link_to_do). Celui qui est en cours de modification.\r\n\r\nCréez une balise ```<a-faire-liste>``` qui englobe tout le HTML et ajoutez y une balise ```<script>```.\r\n\r\n```\r\n<a-faire-liste>\r\n <!-- le HTML -->\r\n <script></script>\r\n</a-faire-liste>\r\n```\r\n\r\n#### Boucle\r\n\r\nPour créer une boucle qui ajoute une balise ```<div class=\"liste-element a-faire\">``` pour chaque élément du modèle, nous lui ajoutons ```each={ liste }```.\r\n\r\n```\r\n<div class=\"liste-element a-faire\" each={ liste }>\r\n```\r\n\r\n#### Afficher une clé de chaque élément\r\n\r\nNous souhaitons avoir la clé ```text``` de l'élément à la place de ```En cours de modification```.\r\n\r\n```\r\n<p>En cours de modification</p>\r\n```\r\n\r\ndevient\r\n\r\n```\r\n<p>{ text }</p>\r\n```\r\n\r\n#### Conditions\r\n\r\n**Les classes de l'élément de la liste**\r\n\r\nSi l'élément est ```fait``` nous voulons que les classes de la ```<div>``` soient ```class=\"liste-element fait\"```, sinon ```class=\"liste-element a-faire\"```.\r\n\r\n```\r\n<div class=\"liste-element a-faire\" each={ liste }\r\n```\r\n\r\ndevient\r\n\r\n```\r\n<div each= {liste} class=\"{fait ? 'liste-element fait' : 'liste-element a-faire'}\">\r\n```\r\n\r\n**Les classes de l'icône pour basculer ```fait```**\r\n\r\nDe la même manière\r\n\r\n```\r\n<span class=\"glyphicon glyphicon-ok\"></span>\r\n```\r\n\r\ndevient\r\n\r\n```\r\n<span class=\"{fait ? 'glyphicon glyphicon-remove' : 'glyphicon glyphicon-ok'}\"></span>\r\n```\r\n\r\n**Le formulaire de mise à jour**\r\n\r\nNous n'allons ajouter la balise ```<div class=\"liste-element-maj\">``` que si l'élément est en cours de mise à jour.\r\n\r\n```\r\n<div if={ maj } class=\"liste-element-maj\">\r\n```\r\n\r\n#### Le contexte du composant\r\n\r\nChaque composant a un contexte ```this``` à l'intérieur d'une balise ```<script>```. Nous allons le lier à une variable ```ctx```. \r\n\r\nLors de la création du composant, nous allons lui passer le modèle. À l'intérieur du composant celui-ci sera accessible en tant que la variable ```opts```. \r\n\r\nDans la vue nous avons défini la boucle ```each={ liste }```, le contexte doit donc avoir accès à notre liste qui dans le modèle est le dictionnaire ```data```\r\n\r\n```\r\n<script>\r\nvar ctx = this\r\nctx.modele = opts\r\nctx.liste = ctx.modele.data\r\n</script>\r\n```\r\n\r\nLe fichier ```lib/composants/a-faire-liste.tag``` en entier:\r\n\r\n```\r\n<a-faire-liste>\r\n\r\n <div each={ liste } class=\"{fait ? 'liste-element fait' : 'liste-element a-faire'}\">\r\n  <div class=\"liste-element-info\">\r\n   <div class=\"liste-element-texte\">\r\n    <p>{ text }</p>\r\n   </div>\r\n   <div class=\"liste-element-modif\">\r\n    <span class=\"glyphicon glyphicon-pencil\"></span>\r\n   </div>\r\n   <div class=\"liste-element-statut\">\r\n    <span class=\"{fait ? 'glyphicon glyphicon-remove' : 'glyphicon glyphicon-ok'}\"></span>\r\n   </div>\r\n  </div>\r\n\r\n  <div if={ maj } class=\"liste-element-maj\">\r\n   <div class=\"liste-element-maj-input\">\r\n    <input class=\"form-control\" id=\"liste-element-maj-input\" type=\"text\">\r\n   </div>\r\n   <div class=\"liste-element-maj-bouton\">\r\n    <button class=\"btn btn-primary\" id=\"liste-element-maj-bouton\">OK</button>\r\n   </div>\r\n  </div>\r\n\r\n </div> \r\n\r\n <script>\r\nvar ctx = this\r\nctx.modele = opts\r\nctx.liste = ctx.modele.data\r\n </script>\r\n\r\n</a-faire-liste>\r\n```\r\n\r\n#### Monter le composant\r\n\r\nNous allons maintenant monter  ```<a-faire-liste>``` dans ```main.js```.\r\n\r\n```\r\nvar riot = require('riot')\r\nvar Modele = require('./lib/Modele-a-faire')\r\nvar aFaireListe = require('./lib/composants/a-faire-liste.tag')\r\n\r\nvar modele = new Modele\r\n\r\nriot.mount('a-faire-liste', modele)\r\n```\r\n\r\nPour vérifiez que tout fonctionne, lancez le scripte ```watch```.\r\n\r\n```\r\n$ npm run watch\r\n```\r\n\r\nEt ouvrez ```public/index.html``` dans un navigateur.\r\n\r\n#### Les contrôleurs du composant\r\n\r\nNous allons maintenant ajouter les contrôleurs.\r\n\r\n**basculerFait**\r\n\r\nQuand l'icône est clickée, basculer fait.\r\n\r\nDans le corps du composant:\r\n\r\n```\r\n<div class=\"liste-element-statut\">\r\n```\r\n\r\ndevient\r\n\r\n```\r\n<div class=\"liste-element-statut\" onclick={ basculerFait }>\r\n```\r\n\r\nDans la balise ```<script>``` du composant:\r\n\r\n```\r\nvar ctx = this\r\nctx.modele = opts\r\nctx.liste = ctx.modele.data\r\n\r\nctx.basculerFait = function(e) {\r\n var index = ctx.liste.indexOf(e.item)\r\n ctx.modele.basculerFait(index)\r\n}\r\n```\r\n\r\nL'événement ```onclick``` passe l'élément de la liste à la fonction. C'est le ```e```. Dans Riot, l'élément de la boucle est accessible par ```e.item```. Nous trouvons l'index de l'élément dans la liste et appelons la méthode ```.basculerFait()``` du modèle.\r\n\r\nSi le scripte ```watch``` tourne encore, vous pouvez vérfier que tout marche dans le navigateur.\r\n\r\n**basculerMaj**\r\n\r\nMaintenant nous voulons montrer la balise ```<div class=\"liste-element-maj\">``` quand nous clickons l'icône avec le crayon.\r\n\r\nDans le corps du composant:\r\n\r\n```\r\n<div class=\"liste-element-modif\" onclick={ basculerMaj }>\r\n```\r\n\r\nDans le scripte du composant:\r\n\r\n```\r\nctx.basculerMaj = function(e) {\r\n if(e.item.maj) { e.item.maj = undefined }\r\n else {\r\n  ctx.liste.forEach(function(element) { element.maj = undefined })\r\n  e.item.maj = true\r\n }\r\n}\r\n```\r\n\r\nNous n'invoquons cette fois pas le modèle, parce que quel élément est en cours de modification ne le concerne pas. Le modèle représente les données sous-jacentes de l'application et ceci fait partie de la logique de présentation.\r\n\r\n**mettreAJour**\r\n\r\nUne fois le formulaire de mise à jour affiché, il faut que la clé ```text``` de l'élément soit modifiée lorsque le boutton est clické.\r\n\r\nDans le corps du composant:\r\n\r\n```\r\n<button class=\"btn btn-primary\" onclick={ mettreAJour }>OK</button>\r\n```\r\n\r\nDans le scripte du composant:\r\n\r\n```\r\nctx.mettreAJour = function(e) {\r\n var index = ctx.liste.indexOf(e.item)\r\n var input = document.getElementById('liste-element-maj-input')\r\n if(input.value) {\r\n  ctx.modele.mettreAJour(index, input.value)\r\n  input.value = ''\r\n  e.item.maj = undefined\r\n }\r\n}\r\n```\r\n\r\nTestez dans le navigateur... \r\n\r\n## Le composant ```<a-faire-formulaire>```\r\n\r\nDans ```lib/composants```, créez un fichier ```a-faire-formulaire.tag```.\r\n\r\n```\r\n<a-faire-formulaire>\r\n <div class=\"ajouter\">\r\n  <div class=\"ajouter-input\">\r\n   <input id=\"ajouter-input\" class=\"form-control\" placeholder=\"À faire\" type=\"text\">\r\n  </div>\r\n  <div class=\"ajouter-bouton\">\r\n   <button id=\"ajouter-bouton\" class=\"btn btn-primary\">Ajouter</button>\r\n  </div>\r\n </div>\r\n <div id=\"supprimer-fait\">\r\n  <button id=\"supprimer-fait-bouton\" class=\"btn btn-danger\">Supprimer ce qui a été fait</button>\r\n </div>\r\n <script></script>\r\n</a-faire-formulaire>\r\n```\r\n\r\nJ'ai ici repris le contenu de la ```<div id=\"formulaire\">``` de ```index.html``` du [chapitre 1](link_to_do).\r\n\r\nDans le scripte du composant, je référence le contexte et le modèle.\r\n\r\n```\r\nvar ctx = this\r\nctx.modele = opts\r\n```\r\n\r\nDans ```main.js```, nous montons ce composant:\r\n\r\n```\r\nvar riot = require('riot')\r\nvar Modele = require('./lib/Modele-a-faire')\r\nvar aFaireListe = require('./lib/composants/a-faire-liste.tag')\r\nvar aFaireFormulaire = require('./lib/composants/a-faire-formulaire.tag') // <- nouveau\r\n\r\nvar modele = new Modele\r\n\r\nriot.mount('a-faire-liste', modele)\r\nriot.mount('a-faire-formulaire', modele) // <- nouveau\r\n```\r\n\r\n### Les contrôleurs de ```<a-faire-formulaire>```:\r\n\r\n**ajouter**\r\n\r\nDans le corps du composant\r\n\r\n```\r\n<button id=\"ajouter-bouton\" class=\"btn btn-primary\">Ajouter</button>\r\n```\r\n\r\ndevient\r\n\r\n```\r\n<button id=\"ajouter-bouton\" class=\"btn btn-primary\" onclick={ ajouter }>Ajouter</button>\r\n```\r\n\r\nDans le scripte du composant\r\n\r\n```\r\nctx.ajouter = function() {\r\n var input = document.getElementById('ajouter-input')\r\n if(input.value) {\r\n  ctx.modele.ajouter(input.value)\r\n  input.value = ''\r\n }\r\n}\r\n```\r\n\r\n**supprimerFait**\r\n\r\nDans le corps du composant:\r\n\r\n```\r\n<button id=\"supprimer-fait-bouton\" class=\"btn btn-danger\">Supprimer ce qui a été fait</button>\r\n```\r\n\r\ndevient\r\n\r\n```\r\n<button id=\"supprimer-fait-bouton\" class=\"btn btn-danger\" onclick={ supprimerFait }>Supprimer ce qui a été fait</button>\r\n```\r\n\r\nDans le scripte du composant\r\n\r\n```\r\nctx.supprimerFait = function() {\r\n ctx.modele.supprimerFait()\r\n}\r\n```\r\n\r\nSi ```watch``` tourne encore, ouvrons le navigateur pour voir si ça marche...\r\n\r\nNon, ça ne marche pas. Le composant ```<a-faire-liste>``` ne sait pas que le modèle a changé. Nous allons faire en sorte que le modèle puisse l'informer quand il doit être mis à jour.\r\n\r\n## Emettre un événement\r\n\r\nOuvrez ```lib/Model-a-faire.js```, en haut de la page, ajoutez:\r\n\r\n```\r\nvar Event = require('events')\r\n```\r\n\r\nNous n'avons pas besoin de télécharger la librairie ```event``` avec NPM, elle fait partie des fonctionnalités de base de Node. \r\n\r\nCréez une méthode \"émetteur\" ```evt``` dans le modèle:\r\n\r\n```\r\nctx.evt = new Event\r\n```\r\n\r\nQuand un élément est ajouté, émettons un événement ```ajout```.\r\n\r\n```\r\n ctx.ajouter = function(text) {\r\n  ctx.data.push({text: text, fait: false})\r\n  ctx.evt.emit('ajout')\r\n }\r\n```\r\n\r\nQuand les éléments ```fait``` sont supprimés émettons un événement ```suppression```.\r\n\r\n```\r\n ctx.supprimerFait = function() {\r\n  var aGarder = []\r\n  ctx.data.forEach(function(element) {\r\n   if(!element.fait) { aGarder.push(element) }\r\n  })\r\n  ctx.data = aGarder\r\n  ctx.evt.emit('suppression')\r\n }\r\n```\r\n\r\nDans le scripte du composant ```lib/composants/a-faire-liste.tag``` demandez au contexte ```ctx``` de se mettre à jour quand ces événements sont émis.\r\n\r\n```\r\nctx.modele.evt.on('ajout', function() { \r\n ctx.liste = ctx.modele.data\r\n ctx.update() \r\n})\r\n\r\nctx.modele.evt.on('suppression', function() { \r\n ctx.liste = ctx.modele.data\r\n ctx.update() \r\n})\r\n```\r\n\r\nSi tout fonctionne comme il faut, arrêtez le scripte ```watch``` (```ctrl-C```) et lancez ```build``` pour créer l'application.\r\n\r\n```\r\n$ npm run build\r\n```\r\n\r\n## Conclusion\r\n\r\nDans ce chapitre nous avons amélioré la lisibilité du code de l'application en créant des composants qui contiennent une vue et les contrôleurs associés. La structure de l'application est modulaire. Nous pouvons réutiliser ces composants dans d'autres parties de l'application ou dans une tout autre application. Le modèle fait ce qu'il a à faire sans ce soucier de la manière dont les données sont présentée.\r\n\r\nNous avons vu comment l'utilisation de librairies externes comme **handlebars** et **riot** peuvent nous faciliter la vie. Dans le prochain chapitre nous allons utiliser le \"framework\" **angular** de Google.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}